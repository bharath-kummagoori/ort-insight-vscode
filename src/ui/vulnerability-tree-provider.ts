/**
 * Vulnerability Tree Provider - Displays security vulnerabilities from ORT Advisor
 */

import * as vscode from 'vscode';
import { Vulnerability, ORTResult } from '../types';
import { ORTParser } from '../ort-parser';
import { getVulnerabilityIcon, formatSeverity } from './ui-utils';
import * as fs from 'fs';

interface VulnerabilityGroup {
  packageId: string;
  packageName: string;
  vulnerabilities: Vulnerability[];
}

export class VulnerabilityTreeProvider implements vscode.TreeDataProvider<VulnTreeNode> {
  private _onDidChangeTreeData = new vscode.EventEmitter<VulnTreeNode | undefined | null | void>();
  readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

  private vulnerabilityGroups: VulnerabilityGroup[] = [];
  private parser: ORTParser;

  constructor() {
    this.parser = new ORTParser();
  }

  /**
   * Refresh the tree view
   */
  refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  /**
   * Load ORT results and extract vulnerabilities
   */
  async loadResults(resultFile: string): Promise<void> {
    try {
      if (!fs.existsSync(resultFile)) {
        this.vulnerabilityGroups = [];
        this.refresh();
        return;
      }

      const ortResult = this.parser.parseResultFile(resultFile);
      this.vulnerabilityGroups = this.extractVulnerabilities(ortResult);
      this.refresh();
    } catch (error) {
      vscode.window.showErrorMessage(`Failed to load vulnerabilities: ${error}`);
      this.vulnerabilityGroups = [];
      this.refresh();
    }
  }

  /**
   * Clear tree data
   */
  clear(): void {
    this.vulnerabilityGroups = [];
    this.refresh();
  }

  /**
   * Get tree item
   */
  getTreeItem(element: VulnTreeNode): vscode.TreeItem {
    return element;
  }

  /**
   * Get children of a tree node
   */
  getChildren(element?: VulnTreeNode): Thenable<VulnTreeNode[]> {
    if (!element) {
      // Root level - show packages with vulnerabilities
      if (this.vulnerabilityGroups.length === 0) {
        const emptyNode = new VulnTreeNode(
          'No vulnerabilities found',
          vscode.TreeItemCollapsibleState.None,
          'empty'
        );
        emptyNode.iconPath = new vscode.ThemeIcon('pass');
        return Promise.resolve([emptyNode]);
      }

      return Promise.resolve(
        this.vulnerabilityGroups.map(group => {
          const node = new VulnTreeNode(
            `${group.packageName} (${group.vulnerabilities.length})`,
            vscode.TreeItemCollapsibleState.Collapsed,
            'package',
            group
          );

          node.iconPath = new vscode.ThemeIcon('package');
          node.description = `${group.vulnerabilities.length} vulnerabilit${group.vulnerabilities.length === 1 ? 'y' : 'ies'}`;

          return node;
        })
      );
    }

    // Children of a package node - show individual vulnerabilities
    if (element.type === 'package' && element.group) {
      return Promise.resolve(
        element.group.vulnerabilities.map(vuln => {
          const node = new VulnTreeNode(
            vuln.id,
            vscode.TreeItemCollapsibleState.None,
            'vulnerability',
            undefined,
            vuln
          );

          node.iconPath = getVulnerabilityIcon(vuln.severity);
          node.description = vuln.severity ? formatSeverity(vuln.severity) : undefined;
          node.tooltip = this.buildVulnerabilityTooltip(vuln);

          // Make clickable to show details
          node.command = {
            command: 'ort-insight.showVulnerabilityDetails',
            title: 'Show Details',
            arguments: [vuln]
          };

          return node;
        })
      );
    }

    return Promise.resolve([]);
  }

  /**
   * Extract vulnerabilities from ORT result
   */
  private extractVulnerabilities(ortResult: ORTResult): VulnerabilityGroup[] {
    const groups: VulnerabilityGroup[] = [];

    if (!ortResult.advisor?.advisories) {
      return groups;
    }

    for (const [pkgId, advisories] of Object.entries(ortResult.advisor.advisories)) {
      const allVulns: Vulnerability[] = [];

      for (const advisory of advisories as any[]) {
        if (advisory.vulnerabilities) {
          allVulns.push(...advisory.vulnerabilities);
        }
      }

      if (allVulns.length > 0) {
        groups.push({
          packageId: pkgId,
          packageName: this.extractPackageName(pkgId),
          vulnerabilities: allVulns
        });
      }
    }

    // Sort by number of vulnerabilities (descending)
    groups.sort((a, b) => b.vulnerabilities.length - a.vulnerabilities.length);

    return groups;
  }

  /**
   * Extract package name from package ID
   */
  private extractPackageName(pkgId: string): string {
    // Package ID format: type:namespace:name:version
    const parts = pkgId.split(':');
    if (parts.length >= 3) {
      return `${parts[2]}@${parts[3] || 'unknown'}`;
    }
    return pkgId;
  }

  /**
   * Build vulnerability tooltip
   */
  private buildVulnerabilityTooltip(vuln: Vulnerability): vscode.MarkdownString {
    const md = new vscode.MarkdownString();

    md.appendMarkdown(`**${vuln.id}**\n\n`);

    if (vuln.severity) {
      md.appendMarkdown(`**Severity:** ${formatSeverity(vuln.severity)}\n\n`);
    }

    if (vuln.cvss) {
      md.appendMarkdown(`**CVSS Score:** ${vuln.cvss}\n\n`);
    }

    if (vuln.summary) {
      md.appendMarkdown(`**Summary:** ${vuln.summary}\n\n`);
    }

    if (vuln.references && vuln.references.length > 0) {
      md.appendMarkdown(`**References:**\n`);
      for (const ref of vuln.references.slice(0, 3)) {
        md.appendMarkdown(`- [${ref.url}](${ref.url})\n`);
      }
      if (vuln.references.length > 3) {
        md.appendMarkdown(`- ... and ${vuln.references.length - 3} more\n`);
      }
    }

    return md;
  }

  /**
   * Get total vulnerability count
   */
  getVulnerabilityCount(): number {
    return this.vulnerabilityGroups.reduce((sum, group) => sum + group.vulnerabilities.length, 0);
  }
}

/**
 * Tree node representing a vulnerability or package
 */
class VulnTreeNode extends vscode.TreeItem {
  constructor(
    public readonly label: string,
    public readonly collapsibleState: vscode.TreeItemCollapsibleState,
    public readonly type: 'package' | 'vulnerability' | 'empty',
    public readonly group?: VulnerabilityGroup,
    public readonly vulnerability?: Vulnerability
  ) {
    super(label, collapsibleState);
  }
}
